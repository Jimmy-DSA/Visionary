/* eslint-disable react-hooks/exhaustive-deps */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/glasses-v1.glb --types 
Author: Andrea Munegato 3D (https://sketchfab.com/andreamunegato)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/glasses-bed4643c801b4a0581333489a5e0b3ea
Title: Glasses
*/

import * as THREE from "three";
import { JSX, useLayoutEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF, KTX2Loader } from "three-stdlib";
import { useFrame, useThree } from "@react-three/fiber";
import gsap from "gsap";
// import { useControls } from "leva";
import useScreenType from "../useScreenSize";
import {
  getEnterAnimationValues,
  getOffersSectionValues,
  getAboutSectionValues,
} from "../animationValues";
import { useCanvasPosition } from "../context/CanvasPositionContext";
import ScrollTrigger from "gsap/ScrollTrigger";

type GLTFResult = GLTF & {
  nodes: {
    Mesh__Base1_0: THREE.Mesh;
    Mesh__Glasses1_0: THREE.Mesh;
    Mesh__Glasses_Side1_0: THREE.Mesh;
    Mesh__T1_0: THREE.Mesh;
    Mesh__nose1_0: THREE.Mesh;
    Mesh__Steel1_0: THREE.Mesh;
  };
  materials: {
    Base1: THREE.MeshStandardMaterial;
    Glasses1: THREE.MeshStandardMaterial;
    Glasses_Side1: THREE.MeshStandardMaterial;
    material: THREE.MeshStandardMaterial;
    nose1: THREE.MeshStandardMaterial;
    Steel1: THREE.MeshStandardMaterial;
  };
};

export default function Glasses(props: JSX.IntrinsicElements["group"]) {
  const { setPosition } = useCanvasPosition();
  const groupRef = useRef<THREE.Group>(null);

  const gl = useThree((state) => state.gl);
  const { nodes, materials } = useGLTF(
    "/glasses.glb",
    true,
    undefined,
    (loader) => {
      const ktx2loader = new KTX2Loader();
      ktx2loader.setTranscoderPath(
        "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets/basis/"
      );
      ktx2loader.detectSupport(gl);
      loader.setKTX2Loader(ktx2loader);
    }
  ) as unknown as GLTFResult;

  const { screenSize, isLoading } = useScreenType();

  // const { cameraPosition, scenePosition, sceneRotation } = useControls({
  //   cameraPosition: {
  //     value: {
  //       x: -8.34,
  //       y: 0.06,
  //       z: 4.64,
  //     },
  //     step: 0.05,
  //   },
  //   scenePosition: {
  //     value: { x: -3.2, y: -0.25, z: 1.75 },
  //     step: 0.05,
  //   },
  //   sceneRotation: {
  //     value: { x: 0, y: 5.23, z: 0 },
  //     step: 0.05,
  //   },
  // });

  useFrame(() => {
    //   camera.position.x = cameraPosition.x;
    //   camera.position.y = cameraPosition.y;
    //   camera.position.z = cameraPosition.z;
    //   scene.position.x = scenePosition.x;
    //   scene.position.y = scenePosition.y;
    //   scene.position.z = scenePosition.z;
    //   scene.rotation.x = sceneRotation.x;
    //   scene.rotation.y = sceneRotation.y;
    //   scene.rotation.z = sceneRotation.z;
  });

  useLayoutEffect(() => {
    // Skip animation setup if still loading
    if (isLoading) return;

    const tl = gsap.timeline();
    const enterAnimation = getEnterAnimationValues(screenSize);
    console.log("enter animation:");
    console.log(enterAnimation);
    const offersSection = getOffersSectionValues(screenSize);
    const aboutSection = getAboutSectionValues(screenSize);

    if (!enterAnimation || !offersSection || !aboutSection) return;

    tl.fromTo(
      scene.position,
      enterAnimation.sceneStart,
      { ...enterAnimation.sceneEnd, ease: "back.out", duration: 2 },
      0
    );

    tl.fromTo(
      camera.position,
      enterAnimation.cameraStart,
      { ...enterAnimation.cameraEnd, ease: "back.out", duration: 2 },
      0
    );

    tl.fromTo(
      scene.rotation,
      enterAnimation.rotationStart,
      { ...enterAnimation.rotationEnd, ease: "back.out", duration: 2 },
      0
    );

    gsap.set(scene.position, enterAnimation.sceneEnd);
    gsap.set(camera.position, enterAnimation.cameraEnd);
    gsap.set(scene.rotation, enterAnimation.rotationEnd);

    // OFFERS SECTION
    tl.to(camera.position, {
      ...offersSection.camera,
      scrollTrigger: {
        trigger: "#offers-section",
        start: "top bottom",
        end: "top 114px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });
    tl.to(scene.position, {
      ...offersSection.scene,
      scrollTrigger: {
        trigger: "#offers-section",
        start: "top bottom",
        end: "top 114px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });
    tl.to(scene.rotation, {
      ...offersSection.rotation,
      scrollTrigger: {
        trigger: "#offers-section",
        start: "top bottom",
        end: "top 114px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });
    gsap.set(camera.position, offersSection.camera);
    gsap.set(scene.position, offersSection.scene);
    gsap.set(scene.rotation, offersSection.rotation);

    // ABOUT SECTION
    tl.to(camera.position, {
      ...aboutSection.camera,
      scrollTrigger: {
        trigger: "#about-section",
        start: "-50px bottom",
        end: "top 100px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });
    tl.to(scene.position, {
      ...aboutSection.scene,
      scrollTrigger: {
        trigger: "#about-section",
        start: "-50px bottom",
        end: "top 100px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });
    tl.to(scene.rotation, {
      ...aboutSection.rotation,
      scrollTrigger: {
        trigger: "#about-section",
        start: "-50px bottom",
        end: "top 100px",
        scroller: "#root",
        scrub: true,
        immediateRender: false,
      },
    });

    // Adiciona o trigger para mudar o comportamento do canvas
    ScrollTrigger.create({
      trigger: "#about-section",
      start: "top 100px",
      end: "bottom bottom",
      scroller: "#root",
      onEnter: () => setPosition("absolute"),
      onLeaveBack: () => setPosition("fixed"),
    });

    return () => {};
  }, [screenSize, isLoading]);

  const { camera, scene } = useThree();

  if (isLoading) {
    return null;
  }

  return (
    <group {...props} dispose={null} scale={2} ref={groupRef}>
      <mesh
        geometry={nodes.Mesh__Base1_0.geometry}
        material={materials.Base1}
      />
      <mesh
        geometry={nodes.Mesh__Glasses1_0.geometry}
        material={materials.Glasses1}
      />
      <mesh
        geometry={nodes.Mesh__Glasses_Side1_0.geometry}
        material={materials.Glasses_Side1}
      />
      <mesh
        geometry={nodes.Mesh__T1_0.geometry}
        material={materials.material}
      />
      <mesh
        geometry={nodes.Mesh__nose1_0.geometry}
        material={materials.nose1}
      />
      <mesh
        geometry={nodes.Mesh__Steel1_0.geometry}
        material={materials.Steel1}
      />
    </group>
  );
}

useGLTF.preload("glasses.glb", true);
